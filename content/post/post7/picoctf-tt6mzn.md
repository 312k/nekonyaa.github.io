---
title: "picoCTF 2021 writeup by tt6mzn"
date: 2021-04-09T07:26:42+09:00
categories: ["Writeup"]
tags: [ "CTF", "Writeup", "tt6mzn", "crypto" ]
math: True
---
## 初めに
[picoCTF 2021](https://play.picoctf.org/events/34)に参加しました。
cryptoの問題を5問解くことができました。
解いた問題は以下です。

* MOD 26
* Mind your Ps and Qs
* Dachshund Attacks
* No Padding, No Problem
* Pixelated
<!--more-->
## Mod 26
### 問題文
> Cryptography can be easy, do you know what ROT13 is?
> cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_hyLicInt}

問題ページ: https://play.picoctf.org/practice/challenge/144?category=2&originalEvent=34&page=1
### 解説
問題文にもある通り、ROT13でflagを暗号化した文字列が与えられているようです。
ROT13とは、各文字をアルファベット順に13文字ずつずらして置き換える、単一換字式暗号の一つです。
アルファベットは全部で26文字なので、2回暗号化すると元に戻るという性質があります。
地道に13文字ずらしても簡単にflagを得ることができますが、プログラムも示しておくことにします。
以下pythonによる実装です。
```python
def main():
    c = "cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_hyLicInt}"  # encrypted flag
    alp = "abcdefghijklmnopqrstuvwxyz"  # アルファベット
    ans = ""  # 出力用文字列
    for t in c:
        if t in alp:  # 小文字の場合
            ans += alp[alp.index(t) - 13]  # 13文字ずらす
        elif t in alp.upper(): # 大文字の場合
            ans += alp[alp.upper().index(t) - 13].upper()  # 13文字ずらす
        else:  # アルファベットでない場合はそのまま加える
            ans += t
    print(ans)

main()
```
出力:
```
picoCTF{next_time_I'll_try_2_rounds_of_rot13_ulYvpVag}
```

## Mind your Ps and Qs
### 問題文
> In RSA, a small e value can be problematic, but what about N?
> Can you decrypt this?

問題ページ: https://play.picoctf.org/practice/challenge/162?category=2&originalEvent=34&page=1

また、以下のテキストが書かれたファイルが与えられます。
```
Decrypt my super sick RSA:
c: 861270243527190895777142537838333832920579264010533029282104230006461420086153423
n: 1311097532562595991877980619849724606784164430105441327897358800116889057763413423
e: 65537
```
### 解説
RSA暗号の問題です。
cは暗号文、nとeは公開鍵でしょう。
問題文で「nが小さい場合にはどのような問題があるか？」と聞かれていることから、nを素因数分解できるのではないかと考えました。
今回は、nの値を[factordb](http://factordb.com/index.php?query=1311097532562595991877980619849724606784164430105441327897358800116889057763413423)に入れるとp, qの値をすぐに取得することができました:
$$p = 1955175890537890492055221842734816092141$$
$$q = 670577792467509699665091201633524389157003$$
pとqの値がわかれば秘密鍵dを計算でき、暗号文を復号することができます。

少し数学の解説をします。
公開鍵eと秘密鍵dの間には、以下の関係があります。
$$
ed \equiv 1 \ (mod \ \phi(n)) \tag{1}
$$
ここで、φ(n)はオイラー関数といい、n以下の自然数のうちnと互いに素であるものの個数を表します。
nはp, qの二つの素数の積であり、素数とオイラー関数に関する諸性質から、次式が成り立ちます。
$$
\phi(n) = \phi(pq) = \phi(p)\phi(q) = (p - 1)(q - 1) \tag{2}
$$
(1)式について、(2)式より、秘密鍵d以外の値がわかっているので、dを求めることができます。
(1)式をよく見ると、dは法φ(n)におけるeの乗法逆元であると分かります。
法φ(n)におけるeの乗法逆元を計算すれば、それがdになるということです。
合同式における乗法逆元は以下のように計算することができます。
合同式の定義から、ある整数kが存在し、(1)式は次のように変形できます。
$$
ed = k\phi(n) + 1
$$
$$
ed - k\phi(n) = 1 \tag{3}
$$
eとφ(n)の値は既知なので、(3)式は未知数にdとkの2つをもつ方程式になります。
この方程式を満たす**整数**の組(d, k)が一組でも見つかれば、秘密鍵を計算できたことになります。
このように、ax + by = 1のような形をした方程式は一次不定方程式と呼ばれ、解を求めるアルゴリズムに**拡張ユークリッドの互除法**があります。
このような方法で秘密鍵dを計算したら、あとは復号です。
暗号文cと平文mの間には次の関係があります。
$$
m = c^d \ (mod \ n)
$$
よって、法をnとし、cをd乗すれば復号完了です。
dはたいてい非常に大きな値となるので、繰り返し二乗法と呼ばれるアルゴリズムを使ってmを計算します。
pythonでは`pow(c, d, n)`を実行することでこれを計算しています。
以下、復号の処理を記述したプログラムです。
```python
import binascii

def extgcd(a, b):
    """
    拡張ユークリッドの互除法のアルゴリズム。
    ax + by = 1を満たす整数解のうち一つを返す。
    dはaとbの最大公約数。
    """
    if b == 0:
        x = 1
        y = 0
        d = a
        return x, y, d
    y, x, d = extgcd(b, a % b)
    y -= a // b * x
    return x, y, d

def main():
    c = 861270243527190895777142537838333832920579264010533029282104230006461420086153423
    n = 1311097532562595991877980619849724606784164430105441327897358800116889057763413423
    e = 65537
    p = 1955175890537890492055221842734816092141
    q = 670577792467509699665091201633524389157003  # factordb.comより、n = p * q
    d, k, _ = extgcd(e, (p - 1) * (q - 1))  # 秘密鍵dを計算 ed ≡ 1 (mod φ(n))
    while d < 0:  # dが負の場合
        d += (p - 1) * (q - 1)  # dが正になるまでφ(n)を加える。d ≡ d + φ(n) (mod φ(n))
    m = pow(c, d, n)  # 復号
    print(binascii.a2b_hex(hex(m)[2:]))  # 復号結果を16進数にしてasciiで読み込む

main()
```
復号によって得られるmも整数ですが、今回は16進数からasciiへ変換するとflagが得られました。

出力:
```
b'picoCTF{sma11_N_n0_g0od_13686679}'
```

## Dachshund Attacks
### 問題文
> What if d is too small? Connect with nc mercury.picoctf.net 30761.

問題ページ: https://play.picoctf.org/practice/challenge/159?category=2&originalEvent=34&page=1

### 解説
与えられたncコマンドを実行すると次のように表示されます
```shell
Welcome to my RSA challenge!
e: 3070829700239455976883878414604093438206266837369717361794763944651532103706202337736349466828056004413456919639172486473404498955339841069845136049100164906613702908041502235945890406177776140981324521044230110718413408112341326701490234365228510119450657191961358433234923061072280228697549683933114501481
n: 110505872233429198169973425316055139805570136075808183559284285621999587838873031254821755017539923544980198703672159247152031606082777918574079803935392404278339509079438647855311312184344197781477471168000495778504359880500385048665789633312963075117728329148430950391376648492385850802904439184297830540199
c: 2710765152254052204350088211730045170026979866972097876665346611429745891295183151829146438240672408168905672840421019823527410925132454967314497420189742261400642836396953571077546511416196939481946798085929694870217596368346321522506929803298854285776090403050813582333739253115979037581174348279474186781
```
RSA暗号の問題です。先ほどの問題と同様に、(e, n)が公開鍵、cは暗号文でしょう。
ぱっと見でeの値が非常に大きいことがわかります。
eの値が大きいので、秘密鍵dの値は小さいのではないかと推測できます。
dの値が十分に小さいときに、公開鍵から秘密鍵を求める方法として**Wiener's Attack**というアルゴリズムが知られています。
実装は[こちら](http://inaz2.hatenablog.com/entry/2016/01/15/011138)のサイトを参考にしました。
正直解説できるほど理解できていません...要勉強です。
```python
import sys
import gmpy2

def continued_fraction(n, d):
    cf = []
    while d:
        q = n // d
        cf.append(q)
        n, d = d, n-d*q
    return cf

def convergents_of_contfrac(cf):
    n0, n1 = cf[0], cf[0]*cf[1]+1
    d0, d1 = 1, cf[1]
    yield (n0, d0)
    yield (n1, d1)

    for i in range(2, len(cf)):
        n2, d2 = cf[i]*n1+n0, cf[i]*d1+d0
        yield (n2, d2)
        n0, n1 = n1, n2
        d0, d1 = d1, d2

def wieners_attack(e, n):
    cf = continued_fraction(e, n)
    convergents = convergents_of_contfrac(cf)

    for k, d in convergents:
        if k == 0:
            continue
        phi, rem = divmod(e*d-1, k)
        if rem != 0:
            continue
        s = n - phi + 1
        D = s*s - 4*n
        if D > 0 and gmpy2.is_square(D):
            return d

n = 81702121259645210848329041298621911731308931528999300611542107483167394520147920988501412851993357290517573032808604824618776206650821201762707694884361695333944060255745971548699981879210199347918079597184207816291633530259703981583733282451269575876354063551829116614248443148345946177485432011804652369581
e = 11609099254909807110101727759408267061621894543044975262498654253408493951585314575221197254212549745656354783012604696930490128993753864169773594360640319507709080627778405645195791512199154607457251637261288752185504729725537738293869976272095762415259541559692195951865902134649996661492510958767684875777

d = wieners_attack(e, n)
print("found d: %d" % d)
```
出力:
```
found d: 12342311800967039706490053962487796040552667932079830404551330408695976430313
```
dの値がわかれば、先ほどの問題(Mind your Ps and Qs)と同じ手順で暗号文を復号できます。

復号結果:
```
picoCTF{proving_wiener_8652838}
```
## No Padding, No Problem
### 問題文
> Oracles can be your best friend, they will decrypt anything, except the flag's ciphertext.
> How will you break it? Connect with nc mercury.picoctf.net 60368.

問題ページ: https://play.picoctf.org/practice/challenge/154?category=2&originalEvent=34&page=1
与えられたncコマンドを実行すると以下のように表示されます。
```shell
Welcome to the Padding Oracle Challenge
This oracle will take anything you give it and decrypt using RSA. It will not accept the ciphertext with the secret message... Good Luck!


n: 98779204515760491613252017713866633644034082126200123842168625557656177578130012687912514131281113056903910303216672999399754424804730783066508774102800055805478423203358748210062773809185231795871320759419243720061802838014524011663006119641482365495865505876313604487704786299806452487627742914384599231357
e: 65537
ciphertext: 1794729203976711872719621459271823848321924470715184664270203469128478181195520330265627097566749316733970674954700745748703888444561753122252779237029902195187463631393160343731688479216594917964898577428323838387486364520875261593810828449831816915495141814464541237636674968360665110753052022800008837592
```
共通鍵(n, e)の値と暗号文(ciphertext)が与えられています。
さらに任意の値を入力するとそれを復号して教えてくれるようです(以下、復号オラクルと呼びます)。
もちろん、解読目標となるciphertextだけは復号してくれません。

### 解説
今回の問題のように、解読の目標となる暗号文以外の任意の値を、任意のタイミングで復号できるような状態で暗号の解読を試みる攻撃モデルを、適応的選択暗号文攻撃(CCA2: Chosen Ciphertext Attack 2)といいます。
この問題は、CCA2の下でRSA暗号を解読せよ、と言われていることになります。

今回求めたいciphertextの復号結果をmとおくことにすると、次式が成り立ちます。
$$
c \equiv m^e \ (mod \ n) \tag{4}
$$
いきなりですが、与えられた共通鍵(n, e)を用いて、2を暗号化してみます。これをrと置きます。
$$
r \equiv 2^e \ (mod \ n) \tag{5}
$$
cにrをかけ合わせると、次のようになります。
$$
rc \equiv 2^e m^e \equiv (2m)^e \ (mod \ n) \tag{6}
$$
ここで、与えられた復号オラクルを使ってrcを復号します。
もちろん、rcはcとは異なる値をとっているので、復号オラクルで復号できます。
(6)式より、復号結果は2mとなるはずです。
仕上げに、法nにおける2の乗法逆元を2mにかければ、mを求めることができます。
$$
m \equiv 2^{-1} 2m \ (mod \ n)
$$
以下はpythonによる実装です。
まずは2を暗号化してrを求め、crを出力するプログラムです。
```python
def main():
    n = 98779204515760491613252017713866633644034082126200123842168625557656177578130012687912514131281113056903910303216672999399754424804730783066508774102800055805478423203358748210062773809185231795871320759419243720061802838014524011663006119641482365495865505876313604487704786299806452487627742914384599231357

    e = 65537
    c = 1794729203976711872719621459271823848321924470715184664270203469128478181195520330265627097566749316733970674954700745748703888444561753122252779237029902195187463631393160343731688479216594917964898577428323838387486364520875261593810828449831816915495141814464541237636674968360665110753052022800008837592
    r = pow(2, e, n)
    cr = (c * r) % n
    print(cr)

main()
```
出力:
```
38813421544463902807387160746592191882226391712461280994989203779950938051212149637014176552066387656684490506543263307752577977438536615918637513639918096032713284556008858850470000334584266127960394862455679131431032567164652889532749356745489578101978000056767621254728192242313283303921746212606615696895
```
これを復号オラクルに入力します。
```shell
Give me ciphertext to decrypt: 38813421544463902807387160746592191882226391712461280994989203779950938051212149637014176552066387656684490506543263307752577977438536615918637513639918096032713284556008858850470000334584266127960394862455679131431032567164652889532749356745489578101978000056767621254728192242313283303921746212606615696895
Here you go: 580550060391700078946913236734911770139931497702556153513487440893406629034802718534645538074938502890769138695361576199930
```
復号結果は2mとなっているはずです。
復号結果に2の乗法逆元をかけ、mを求めます。
```python
import binascii


def extgcd(a, b):
    if b == 0:
        x = 1
        y = 0
        d = a
        return x, y, d
    y, x, d = extgcd(b, a % b)
    y -= a // b * x
    return x, y, d


def main():
    n = 98779204515760491613252017713866633644034082126200123842168625557656177578130012687912514131281113056903910303216672999399754424804730783066508774102800055805478423203358748210062773809185231795871320759419243720061802838014524011663006119641482365495865505876313604487704786299806452487627742914384599231357
    e = 65537
    c = 1794729203976711872719621459271823848321924470715184664270203469128478181195520330265627097566749316733970674954700745748703888444561753122252779237029902195187463631393160343731688479216594917964898577428323838387486364520875261593810828449831816915495141814464541237636674968360665110753052022800008837592
    r = pow(2, e, n)
    cr = (c * r) % n

    dec_cr = 580550060391700078946913236734911770139931497702556153513487440893406629034802718534645538074938502890769138695361576199930

    inv_2, _, _ = extgcd(2, n)
    m = (inv_2 * dec_cr) % n
    print(binascii.a2b_hex(hex(m)[2:]))


main()
```
出力:
```
b'picoCTF{m4yb3_Th0se_m3s54g3s_4r3_difurrent_3279013}'
```
暗号アルゴリズムは、平文から暗号文を得る関数だと考えることができます。
これをfと置くことにします。
暗号アルゴリズムfが次の性質を満たすとき、その暗号は乗法に対して準同型性を持っているといいます。
$$
f(m_{1})f(m_{2}) = f(m_{1}m_{2})
$$
日本語で表現するならば、「暗号化の積は、積の暗号化」といったところでしょうか。
RSA暗号の暗号化においても、この性質が成り立ちます:
$$
c_{1} = m_{1}^e \ (mod \ n)
$$
$$
c_{2} = m_{2}^e \ (mod \ n)
$$
の時、
$$
c_{1}c_{2} = m_{1}^e m_{2}^e \ (mod \ n) = (m_{1}m_{2})^e \ (mod \ n)
$$
今回のような方法でmを求めることができるのはRSA暗号が乗法に対して準同型性を持っているからです。
## Pixelated
### 問題文
> I have these 2 images, can you make a flag out of them?

問題ページ:
https://play.picoctf.org/practice/challenge/100?category=2&originalEvent=34&page=1

次の二つの画像が与えられています。

![scrambled1.png](../scrambled1.png)
![scrambled2.png](../scrambled2.png)

### 解説
画像が与えられていますので、視覚暗号の一つなのではないかと考えました。
二つの画像のサイズが等しいので、足し算など何らかの重ね合わせの処理で意味のある画像が復元できるような気がします。
そこで、二つの画像を読み込み、ピクセルごとの和をとった画像を出力してみます。
pythonを使って実装しました。
画像の読み込みはpillow(PIL)というライブラリが便利でした。
```python
from PIL import Image
import numpy as np


def main():
    # 画像の読み込み
    img1 = Image.open('scrambled1.png')
    img2 = Image.open('scrambled2.png')

    # imgをarrayに変換
    img1_pixels = np.array(img1)
    img2_pixels = np.array(img2)

    # 画像の和をとる
    img3_pixels = img1_pixels + img2_pixels

    # Imageオブジェクトに戻して保存
    img3 = Image.fromarray(img3_pixels)
    img3.save("scrambled3.png")
    

main()
```
出力:

![scrabled3.png](../scrambled3.png)

## 終わりに
以上が自分が解いた問題になります。
暗号の勉強の成果が少しは出たのかなと思いましたが、まだまだ知識不足ですので精進します。
また、説明の粒度が問題によってばらつきが出てしまったように思います。
よりよいwrite upをかけるように努力したいです。